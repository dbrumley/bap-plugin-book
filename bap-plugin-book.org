#+BABEL:


* Assignments
** Assignment: Read Real World OCaml Language Concepts
 The first section of Real World OCaml (RWO) is called Language
 Concepts, and includes a thorough introduction to OCaml and modern
 OCaml idioms. 
** Assignment: Set up BAP

 Install BAP from opam.  Make sure you pin against git.  See the BAP
 wiki for instructions on how to do this.

** Assignment: Set up emacs

If your first thought is "I'll use vi/vim", you are missing a
fundamental opportunity to become a competent programmer.  A competent
programmer knows many tools.  In particular, vi/vim and emacs are the
two most popular editors.  If you don't know emacs, you don't know
half of what you should on a very basic topic.

Consult the BAP wiki for setting up emacs. In particular, you should
set up:
  - Emacs
  - Tuareg mode using the opam version files (not melpa)
  - Merlin mode using the opam version (not melpa)

If you like you can also consult [[https://github.com/dbrumley/dotfiles/tree/master/emacs.d][David's Document Emacs]]
configuration as an additional reference.

You will also want to consult documentation for using Tuareg and
Merlin. On reference is the [[http://www.typerex.org/files/cheatsheets/tuareg-mode.pdf][OCaml Tuareg Cheat Sheet]]. The following
are essential keystrokes:
  - =C-c C-l= to jump to the =mli= file for a type.
  - =C-c C-t= to show the type of an expression.

** Assignment: Find and read =bap.mli=
Recall in OCaml an =mli= file is an interface file. The file =bap.mli=
contains a complete description of the BAP interface, including data
types and all functions available. 

** Assignment: Write Basic Plugin
 Write a BAP plugin that prints "Hello World!\n".  

 The purpose of this plugin is: 
   1. Ensure your environment is set up properly
   2. Check that you know how to write the most basic BAP code.
   3. Check that you can compile code.

** Assignment: Matching Architecture

 You are given two files: an x86 file called =exe.x86= and an ARM file
 called =exe.arm=. Your goal is to write a plugin that when given an
 ARM file prints out "I found an ARM", when given an x86 file prints
 out "I found an x86", and when given any other type of file outputs
 "No match".

 The purpose of this plugin is:
   1. Look at the basic =Project.t= type
   2. Ensure you know how to pattern match against polymorphic
      variants. 

** Assignment: Print out the disassembly of a file

 You are given a single =exe.arm= file. Your goal is to write a plugin
 that prints out for each instruction a) it's address in hex, and b)
 the assembly string.

 The purpose of this plugin is:
   1. Look at the =Project.t= =disasm= field.
   2. Gain experience working with =Disasm= module.

** Assignment: Write out all .rodata sections in an ELF file
 
 You are given an ELF file called =exe.arm=.  Your goal is to write a
 plugin that prints out all ELF sections marked as =.rodata= in hex. 

 The purpose of this plugin is:
   1. Understand how to work with the =memory= component of a project.
   2. Gain experience using BAP's Universal Values.


* BAP Plugins: An Introduction
** Why OCaml?

We recognize OCaml is typically not someone's first programming
language.  Why not use a more main stream language? 

BAP is written in OCaml because it provides strong type safety
guarantees, has a nice module system, and creates fast code.  BAP is
not for novice programmers. BAP is designed for rigorous program
analysis, and built in a framework that tries to support reasonable
safety and type guarantees.  As such, BAP uses what many call advanced
programming features.

OCaml is just the right tool for the job. Binary analysis is tough
enough without having to worry about run time errors and weak type
systems. There are a million ways you can shoot yourself in the foot.
BAP's goal is to remove bullets due to poor programming practices,
leaving only bullets due to more fundamental algorithm issues. Part of
this is about scientific integrity: we are constantly performing
research and publishing papers, and we're committed to making the BAP
code available for those papers.  Bugs could color the results, thus
it makes sense to try and limit bugs by using programming best
practices.

In addition, program analysis is generally easier in a functional
language like OCaml. As an interesting anecdote, we've seen this play
out even in the Carnegie Mellon University undergraduate compiler
course.  I was a graduate student TA'ing the class for Ed Clarke
(Turing Award winner) and Peter Lee (then CS Department Head, now VP
at Microsoft)in the early 2000's.  We allowed students to pick a
language for their compiler: C, Java, or ML. There was a striking
trend: those who picked ML generally received an A *regardless* of
whether they knew ML before starting the class.  Those who picked Java
generally got a B: their code worked but their algorithms were not
fast, and the code generated was lackluster.  Those who picked C
generally did very poorly, often struggling to get the end-to-end
compiler from parsing to code generation working reliably. Today CMU
does not let students pick a language: they have to use ML.


In my opinion, binary analysis is even tougher than normal
source-based analysis.  High level programs have types, high-level
control flow, and other programming features that provide abstractions
to improve productivity. Compilation gets to take advantage of these
abstractions.  Binary analysis, however, does not have these
abstractions, and must constantly manage uncertainty.  For example, in
source you typically know the control flow graph; in binary analysis
we typically are coping with uncertainty about the graph. In source,
you have types. In binary analysis we are trying to infer the type,
and don't know whether the 32-bit register value is an integer,
unsigned integer, pointer, or something else all together. This all
puts an exclamation point on the need for using the best language for
the job.


Why not lower the entry barrier, e.g., by using a language like
Python?  We would love to, but that is not our main goal right
now. Our main goal is to try and get binary analysis right. We do
provide some python bindings, and update them as we have
time. However, we encourage people to use OCaml directly. 

Don't be scared if you don't know OCaml.  OCaml doesn't let you be
sloppy, so you may feel less productive, especially at first.  This is
just you become a more experienced programmer and better computer
scientist.


** Program to analyze

We will be analyzing the following example, which is an (intentionally
non-optimal) program that counts the frequency of letters in an input:

#+BEGIN_SRC C :tangle exe.c
#include <stdio.h>
#include <ctype.h>

int count(char *str)
{
  int lettercount[26];
  int i, count, l;

  for(i=0; i < 26; i++) lettercount[i] = 0;
  i = 0;
  count = 0;

  while(str[i] != 0){
   l = tolower(str[i]);
   count++;
   if(l >= (int)'a' && l <= (int)'z'){
      lettercount[l-(int)'a'] ++;
   }
   i++;
  }
  for(i =0; i < 26; i++)
    printf("%c: %d ", i+'a', lettercount[i]);
  printf("\n");
  return count;
}

int main(int argc, char *argv[])
{
  if(argc > 1) {
    return count(argv[1]);
  }  else {
    printf("Usage: %s <string>\n", argv[0]);
    printf("\tPrints a count for each letter in <string>\n");
    printf("\tReturns total number of characters counted.\n");
  }
  return 0;
}
#+END_SRC

#+RESULTS:
| Usage:  | /var/folders/xj/kkd3v_ls0yjbyz5sj6spjskw0000gn/T/babel-88225amK/C-bin-88225ZqK | <string> |     |            |          |    |          |
| Prints  | a                                                                              | count    | for | each       | letter   | in | <string> |
| Returns | total                                                                          | number   | of  | characters | counted. |    |          |

Compiled with:
#+BEGIN_SRC sh :verbatim
gcc -g  exe.c -o exe
#+END_SRC

#+RESULTS:


** A Basic Plugin

Plugins interact with BAP via the =Plugin= module.  All plugins must
_register_ with the BAP system.  When you write a plugin, you specify
a function that gets in a =Plugin.t=, which is filled in by BAP. 

Let's start a very basic plugin that just prints "Hello World\n".
Call the file =simplehello.ml=, and type in:

#+BEGIN_SRC ocaml :tangle simplehello.ml
open Core_kernel.Std
open Bap.Std
    
let main p = 
  Printf.printf "Hello world!\n";
  p

let () = Project.register_pass' "hello" main
#+END_SRC


Plugins must be registered with the BAP system.  There are a few
functions for registering passes. The one above registers a pass that
returns unit (i.e., the pass will only be executed for side effects)
that is called "hello" and uses the function =main= for the pass
implementation.

Plugins are compiled with the BAP =bapbuild= command, which takes care
of linking against the BAP libraries. =bapbuild= works like
=corebuild= for the Jane Street Core library.

If the above Save the file as =simple.ml=, then to compile it as a
plugin you would run:
#+BEGIN_SRC sh  :results verbatim
bapbuild simplehello.plugin
#+END_SRC


Plugins are run via the =bap= utility using the =-l= option. Here we
are running the =simple.plugin= (note we can omit the =.plugin=
suffix) on the file =exe.arm=:

#+name: hello1
#+BEGIN_SRC shell :exports results 
bap -lsimplehello exe
#+END_SRC


Which should result in output that includes "Hello World!" at the end:
#+RESULTS: hello1
: Hello world!

In the rest of this document we will go examples of using BAP via the
plugin system. We will see how plugins can access the disassembly, see
symbol tables, view the BAP IR, and more.  We use the example ELF
executable file =exe= as created above as our running example, and
focus on static analysis of executable programs.  Even if you want to
analyze other sources (e.g., traces), understanding how executables on
disk are analyzed is a good place to start.


We describe information using the following format:
 1) We first  give a high level concept
 2) We next provide an example plugin that exhibits the desired
    functionality.
 3) We provide a more detailed breakdown of the plugin code. 


*Main Points:*
 - Plugins interact with BAP via the =Plugin= module.
 - Compile with the =bapbuild= system.
 - Plugins are run with the =-l= command line option.


* =arch=: Interacting with architecture information

Binary analysis usually starts with understanding the basic
architecture format. For example, suppose you want to specialize to
ARM where your analysis assumes return values are in =r0=.  Then as
part of plugin initialization it would be good to check the
architecture matches ARM.  (Note that BAP provides basic inference for
where arguments are returns are located, thus this example is somewhat
moot. However, it illustrates the point.)

BAP currently support all llvm-3.4 architectures, including x86,
x86-64, ARM (v4-v7, and thumb modes), ppc, spark, and more. The full
set is listed in the =Arch= module in =bap.mli=.  (We will reiterate
many times you should get use to browsing the =bap.mli= file, which
contains complete information on everything that BAP provides.)

Here is a simple example that checks the architecture, and prints out
a message based on the architecture type:

#+BEGIN_SRC ocaml :tangle simplearch.ml
(* simplearch.ml *)
open Core_kernel.Std
open Bap.Std

let main p =
  let s = match Project.arch p with
    | #Arch.arm  -> "I found an ARM"
    | #Arch.x86  -> "I found x86"
    | _ -> "No match!"
  in
  Printf.printf "%s\n" s

let () = Project.register_pass' "simplearch" main
#+END_SRC


We compile this:
#+BEGIN_SRC sh
bapbuild simplearch.plugin 
#+END_SRC


And run on an ARM executable:
#+BEGIN_SRC sh :results verbatim
bap -lsimplearch exe
#+END_SRC

#+RESULTS:
: I found x86

This program highlights pattern matching on _polymorphic variant_
types:
#+BEGIN_SRC ocaml
  let s = match Project.arch p with
    | #Arch.arm  -> "I found an ARM"
    | #Arch.x86  -> "I found x86"
    | _ -> "No match!"
  in ...
#+END_SRC

First, notice the =#Arch.arm= indicates a pattern match on something
in the =Arch= module.  If you look at =Arch= in =bap.mli=, you will
notice that the type of =arm= looks something like:
#+BEGIN_SRC ocaml
    type arm = [
      | `arm
      | `armeb
      | `armv4
      | `armv4t
      | `armv5
      | `armv6
      | `armv7
      | `thumb
      | `thumbeb
    ] with bin_io, compare, enumerate, sexp
#+END_SRC

First, look at the variant-looking type declaration =`arm=, =`armeb=,
=`armv4=, etc. Notice the backtick.  The backtick =`= indicates that
each item is a _polymorphic variant_ type, which are discussed in
[[https://realworldocaml.org/v1/en/html/variants.html][Chapter 6 of RWO]].  

Here we are defining a pattern of polymorphic variants called =arm=.
The =match= statement matches every variant in the pattern, and is
shorthand for:

#+BEGIN_SRC ocaml
  let s = match Project.arch p with
    | `Arch.armv4  -> "armv4"      
    | `Arch.armv5  -> "armv5"
    | ... 
#+END_SRC

** Anti-example 1

What's wrong with the following?
#+BEGIN_SRC ocaml
  let s = match Project.arch p with
    | arm  -> "arm"      
    | x86  -> "x86"
    | _ -> "No match!"
  in ...
#+END_SRC


Think about it for a second.

The important thing to notice is the match is against =arm=, not
=#arm=.  =arm= is a variable name, and will match everything. This is
a bug: none of the other cases will ever be true.  Contrast with the
correct way earlier where we matched against the pattern =#arm=.

** The High Bits
 - A project has information about the architecture, which can be used
   to parameterize a plugin specific to a particular architecture.
 - BAP uses polymorphic variants, and matching against classes is
   useful.
 - Be careful with matching. OCaml types help prevent mistakes, but
   don't catch them all. RWO has an entire block at the end of Chapter
   6 talking about the pros and cons of polymorphic variants.


** TODO =Arch= and =Regular=
Extend example to include Regular printing =to_string=


** DONE Why not to_string for Arch?
Everything that implements Regular includes Printable, and everything
(including regular and more) that include Printable have to_string.


* =disasm=: Disassembly

BAP =disasm= module provides access to disassembly and lifters.  BAP
calls LLVM on the back end for disassembly, thus supports
out-of-the-box all architectures supported by LLVM.  You can iterate
over instructions (e.g., using =Disasm.insns=), get an instruction at
an address (e.g., using =Disasm.insn_at_addr=), work with instruction
tags (e.g., using =Disasm.insn=), and many other things. See the
=Disasm= module inside =bap.mli=.

Let's write two programs: one to print out all disassembled
instructions with their addresses, and one to work with tags. 

** Disassembled instructions

In this project we print out the instructions in =Project.disasm=.
Let's first look at the code, then break down how it works.


#+BEGIN_SRC ocaml :tangle simpledisasm.ml
  (* simplediasm.ml *)
  open Core_kernel.Std
  open Bap.Std
       
  let main p = 
    Seq.iter (Disasm.insns (Project.disasm p)) ~f:(fun (mem,insn) -> 
        Printf.printf "%a %s\n"
          Addr.pp (Memory.min_addr mem) (Insn.asm insn)
      )

  let () = Project.register_pass' "disasm" main
#+END_SRC

Let's walk through the code.  The overall skeleton is the same as our
very first simple project where we register a function =main= as our
plugin start.

First, we retrieve a sequence of instructions via:
#+BEGIN_SRC ocaml
Disasm.insns (Project.disasm p)
#+END_SRC

Next, we use =Seq.iter= to iterate over a sequence of =(mem,insn)=
pairs, where =insn= is the instruction and =mem= is the memory where
it appears.

#+BEGIN_SRC ocaml
    Seq.iter (Disasm.insns (Project.disasm p)) ~f:(fun (mem,insn) -> 
     ... )
#+END_SRC


The =insn= is self explanatory: it's the decoded instruction.  You can
view the assembly with =Insn.asm insn=.

The =mem= is a memory region for the particular instruction.
Therefore, the =min_addr= is the start of the instruction, which is
what we print out:
#+BEGIN_SRC ocaml
Printf.printf "%a %s\n"
   Addr.pp (Memory.min_addr mem) (Insn.asm insn)
#+END_SRC

If we wanted to find the length of the instruction we would use
=Memory.length mem=,  and you could hexdump the instruction with
=Memory.hexdump=. 


** Anti-example:

Here is another example of something that seems to print out the
address.


#+BEGIN_SRC ocaml :tangle simpledisasm.ml
(* simplediasm.ml *)
open Core_kernel.Std
open Bap.Std

let main p = 
  let module Target = (val target_of_arch (Project.arch p)) in 
  Seq.iter (Disasm.insns (Project.disasm p)) ~f:(fun (mem,insn) -> 
      Printf.printf "%s %s\n"
        (Bitvector.to_string (Target.CPU.addr_of_pc mem)) (Insn.asm insn)
  )

let () = Project.register_pass' "disasm" main
#+END_SRC

This is very similar to above, except we're passing =mem= to
=Target.CPU.addr_of_pc=.  However, the PC may not be pointing to the
value of the instruction executed. For example, on ARM when CPU
executes instruction at address `A` the value of PC register would
be`A+8`, since at some point of time it had pipeline of two
instructions: exec-load-fetch. In x86 it will point to the byte next
to the instruction, i.e. `PC = A + sizeof(insn)`, on MIPS it is also
points somewhere, ahead.


** Finding what you need in BAP

There is an important meta-point in the above description. As part of
this tutorial was also want to help you figure out *how* to find what
you need in BAP. For example, if this is the first time you are
looking at BAP, perhaps you did not know what =disasm= was in the
project, nor how to use it.  This is where learning to read =bap.mli=
is important.

We see =type disasm= in =bap.mli=, but what functions take this?  A
typical convention we follow is that for something of type =foo= we
have a module =Foo= (note the upper-case).  In this case =Disasm= is
what you want.

Perusing the file, you would find the following function that looks
about right: it takes a =disasm= and returns a sequence that includes
=insns=.

#+BEGIN_SRC ocaml
Disasm.insns: t -> (mem * insn) seq
#+END_SRC

Next, you may not know what a sequence is, since they are often not
covered in introductory OCaml books.  In BAP, a sequence is a list of
items generated lazily on demand (similar to Jane Street Core).  Lazy
generation has a couple of nice properties. First, we don't need to
keep the entire sequence in memory.  Second, if generating each item
is expensive, but we don't think we'll use all of them, we don't need
to pay the full expense.  The main disadvantage is that sequences
typically assume sequential access, e.g., you don't go backward.  In
comparison, consider a non-lazy data structure like a =List=, where
the entire data structure must be available in memory before it can be
used.

If you've never seen =seq= before, you would use emacs (e.g., use =C-c
C-t= and have merlin take you to it)) to jump to the signature for
=Seq=:
#+BEGIN_SRC ocaml
  (** Lazy sequence  *)
  module Seq : sig
    type 'a t = 'a Sequence.t
    include module type of Sequence with type 'a t := 'a t
    val of_array : 'a array -> 'a t

    val cons : 'a -> 'a t -> 'a t

    val is_empty : 'a t -> bool
  end
#+END_SRC

So our =Seq.t= is defined in terms of =Sequence.t=.  At this point you
probably can't jump to the definition of =Sequent.t= because it's in
Jane Street =Core_kernel=.  It's also worth pointing out the =include
module= statement: it will bring in functions available from the
included module.

At this point you would turn to the web and google for something like
"sequence jane street core_kernel".  This is where you find you can
iterate over it with =iter=. You will find other handy functions like
maps and folds over sequences.

** Summary
 - =Disasm= is where you want to look for disassembly information
 - All executable code (segments/sections) are disassembled and
   available via project.
 - The PC isn't the same as the address of the =insn= code. 


** TODO Working with Instruction Tags
This should be a code example with instruction tags as describe in the
intro for this part.



*** TODO =memory=: Memory map and symbols

The =memory= data structure is the BAP memory model of the executable
image.  It includes tagged items like:
  - =Image.region= for memory regions that have a particular name,
    e.g., sections have names in ELF.
  - =Image.section= Binary images typically have sections (aka
    segments) will have the corresponding memory region
    marked. Sections provide access to permission information.
  - =Image.symbol= for annotating with symbol names. 

In this example we will create a plugin that prints out all section
names and permissions.   First we will see the plugin, and then I'll
discuss the concepts.


**** Printout sections and regions
This is terrible code and needs fixing.

#+BEGIN_SRC ocaml tangle:simplememory.ml
open Core_kernel.Std
open Bap.Std
    
let main p = 
  let open Project in
  let print_region tag =
    match Value.get Image.region tag with
    | Some(r) -> Printf.printf "Region: %s\n" r
    | None -> ()
  in
  let print_symbol tag =
    match Value.get Image.symbol tag with
    | Some(r) -> Printf.printf "Symbol: %s\n" r
    | None -> ()
  in
  let print_section tag = 
    match Value.get Image.section tag with
    | Some(r) -> Printf.printf "Section: %s\n"
                   (Sexp.to_string (Image.Sec.sexp_of_t r))
    | None -> ()
  in
  Memmap.iteri (p.memory) ~f:(fun (mem,value) ->
      match Value.get Image.region value with
      | Some ".rodata" ->  Memory.hexdump mem
      | None -> ()
  );
  p

let () = Project.register_plugin main
#+END_SRC

**** TODO Add memmap iteri


**** Segment vs. Section

Among executable container formats, e.g., ELF, PE, etc., you will find
the terms 'segment' and 'section' often used, but the definitions may
be inconsistent across formats. For example, the [[http://en.wikipedia.org/wiki/Executable_and_Linkable_Format][ELF file format]] has
segments, which are needed at runtime, and sections, which are used
for linking and relocation.  A segment may have zero or more sections.
However, the [[http://en.wikipedia.org/wiki/Portable_Executable][PE file format]] talks only of sections, which serve both
purposes. 

It can get confusing.  In BAP we use sections to refer to the part of
the image that has permissions applied (e.g., segments in ELF), and
used regions to denote concepts like sections in ELF.

**** Universal Values
The names are stored as [[https://blogs.janestreet.com/rethinking-univ/][universal types]].

**** TODO region and section in bap.mli both refer to sections
The documentation could be more helpful to a novice: Image.region
refers to ELF sections, and Image.section refers to sections as
segments.  The document may be accurate, but reflects an internal
understanding that is not made explicit.

**** TODO What is the easiest way to get all memory regions?
For example, if you want to find the ro segments.
**** TODO ask IVG about match on Universal values
It would seem somewhat natural to match on the value memmap, e.g.,
something like:
#+BEGIN_SRC ocaml
      match Value.tag tag with
      | Image.region -> do_something tag
      | Image.section -> do_something tag
      | Image.symbol -> do_something tag
      | _ -> do_nothing()
#+END_SRC

What is the idiomatic way to do this?

print_section value = 
  ( match Value.get section value  with
  | Some x -> actuall print |
  | None ->  ()             |
  ); value                         |r

Memmap.iter (fun value ->
  print_section tag  |> print_segment tag |>
)

*** TODO =program=: Program

#+BEGIN_SRC ocaml tangle:simpleprogram.ml
open Core_kernel.Std
open Bap.Std
    

let main p = 
  Printf.printf "Hello world!\n";
  p

let () = Project.register_plugin main
#+END_SRC


*** TODO =storage=: User storage for analysis
#+BEGIN_SRC ocaml tangle:simplestorage.ml
open Core_kernel.Std
open Bap.Std
    

let main p = 
  Printf.printf "Hello world!\n";
  p

let () = Project.register_plugin main
#+END_SRC





